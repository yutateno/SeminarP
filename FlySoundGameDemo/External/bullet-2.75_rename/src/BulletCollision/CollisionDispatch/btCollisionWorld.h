/*
Bullet Continuous Collision Detection D_and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://bulletphysics.com/Bullet/

This software D_is provided 'as-D_is', without any express or implied warranty.
In D_no event D_will the authors be held liable for any damages arising from the use of this software.
Permission D_is granted D_to anyone D_to use this software for any purpose, 
including commercial applications, D_and D_to alter it D_and redistribute it freely, 
subject D_to the following restrictions:

1. The origin of this software D_must not be misrepresented; you D_must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but D_is not required.
2. Altered source versions D_must be plainly marked as such, D_and D_must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


/**
 * @mainpage Bullet Documentation
 *
 * @section intro_sec Introduction
 * Bullet Collision Detection & Physics SDK
 *
 * Bullet D_is a Collision Detection D_and Rigid Body Dynamics Library. The Library D_is Open Source D_and free for commercial use, under the ZLib license ( http://opensource.org/licenses/zlib-license.php ).
 *
 * There D_is the Physics Forum for feedback D_and general Collision Detection D_and Physics discussions.
 * Please visit http://www.bulletphysics.com
 *
 * @section install_sec Installation
 *
 * @subsection step1 Step 1: Download
 * You D_can download the Bullet Physics Library from the Google Code repository: http://code.google.com/p/bullet/downloads/list
 * @subsection step2 Step 2: Building
 * Bullet comes with autogenerated Project Files for Microsoft Visual Studio 6, 7, 7.1 D_and 8.
 * The main Workspace/Solution D_is located in Bullet/msvc/8/wksbullet.sln (replace 8 with your version).
 * 
 * Under other platforms, like Linux or Mac OS-X, Bullet D_can be build using either using make, cmake, http://www.cmake.org , or jam, http://www.perforce.com/jam/jam.html . cmake D_can autogenerate Xcode, KDevelop, MSVC D_and other build systems. D_just run cmake . in the root of Bullet.
 * So if you D_are not using MSVC or cmake, you D_can run ./autogen.sh ./configure D_to create both Makefile D_and Jamfile D_and then run make or jam.
 * Jam D_is a build system that D_can build the library, demos D_and also autogenerate the MSVC Project Files.
 * If you don't have jam installed, you D_can make jam from the included jam-2.5 sources, or download jam from ftp://ftp.perforce.com/jam
 * 
 * @subsection step3 Step 3: Testing demos
 * Try D_to run D_and experiment with BasicDemo executable as a starting point.
 * Bullet D_can be used in several ways, as Full Rigid Body simulation, as Collision Detector Library or Low Level / Snippets like the GJK Closest Point calculation.
 * The Dependencies D_can be seen in this documentation under Directories
 * 
 * @subsection step4 Step 4: Integrating in your application, full Rigid Body D_and Soft Body simulation
 * Check out BasicDemo how D_to create a D_btDynamicsWorld, D_btRigidBody D_and D_btCollisionShape, Stepping the simulation D_and synchronizing your graphics object transform.
 * Check out SoftDemo how D_to use soft body dynamics, using D_btSoftRigidDynamicsWorld.
 * @subsection step5 Step 5 : Integrate the Collision Detection Library (without Dynamics D_and other Extras)
 * Bullet Collision Detection D_can also be used without the Dynamics/Extras.
 * Check out D_btCollisionWorld D_and D_btCollisionObject, D_and the CollisionInterfaceDemo.
 * @subsection step6 Step 6 : Use Snippets like the GJK Closest Point calculation.
 * Bullet has been designed in a modular way keeping dependencies D_to a minimum. The ConvexHullDistance demo demonstrates direct use of D_btGjkPairDetector.
 *
 * @section copyright Copyright
 * Copyright (C) 2005-2008 Erwin Coumans, some contributions Copyright Gino van den Bergen, Christer Ericson, Simon Hobbs, Ricardo Padrela, D_F Richter(res), Stephane Redon
 * Special thanks D_to all visitors of the Bullet Physics forum, D_and in particular above contributors, John McCutchan, Nathanael Presson, Dave Eberle, Dirk Gregorius, Erin Catto, Dave Eberle, Adam Moravanszky,
 * Pierre Terdiman, Kenny Erleben, Russell Smith, Oliver Strunk, Jan Paul van Waveren, Marten Svanfeldt.
 * 
 */
 
 

#ifndef COLLISION_WORLD_H
#define COLLISION_WORLD_H

class D_btStackAlloc;
class D_btCollisionShape;
class D_btConvexShape;
class D_btBroadphaseInterface;
#include "LinearMath/btVector3.h"
#include "LinearMath/btTransform.h"
#include "btCollisionObject.h"
#include "btCollisionDispatcher.h"
#include "BulletCollision/BroadphaseCollision/btOverlappingPairCache.h"
#include "LinearMath/btAlignedObjectArray.h"

///CollisionWorld D_is interface D_and container for the collision detection
class D_btCollisionWorld
{

	
protected:

	D_btAlignedObjectArray<D_btCollisionObject*>	m_collisionObjects;
	
	D_btDispatcher*	m_dispatcher1;

	D_btDispatcherInfo	m_dispatchInfo;

	D_btStackAlloc*	m_stackAlloc;

	D_btBroadphaseInterface*	m_broadphasePairCache;

	D_btIDebugDraw*	m_debugDrawer;

	///m_forceUpdateAllAabbs D_can be set D_to false as an optimization D_to D_only update active object AABBs
	///it D_is true by default, because it D_is error-prone (setting the position of static objects wouldn't update their AABB)
	bool m_forceUpdateAllAabbs;

public:

	//this constructor doesn't own the dispatcher D_and paircache/broadphase
	D_btCollisionWorld(D_btDispatcher* dispatcher,D_btBroadphaseInterface* broadphasePairCache, D_btCollisionConfiguration* collisionConfiguration);

	virtual ~D_btCollisionWorld();

	void	setBroadphase(D_btBroadphaseInterface*	pairCache)
	{
		m_broadphasePairCache = pairCache;
	}

	const D_btBroadphaseInterface*	getBroadphase() const
	{
		return m_broadphasePairCache;
	}

	D_btBroadphaseInterface*	getBroadphase()
	{
		return m_broadphasePairCache;
	}

	D_btOverlappingPairCache*	getPairCache()
	{
		return m_broadphasePairCache->getOverlappingPairCache();
	}


	D_btDispatcher*	getDispatcher()
	{
		return m_dispatcher1;
	}

	const D_btDispatcher*	getDispatcher() const
	{
		return m_dispatcher1;
	}

	void	updateSingleAabb(D_btCollisionObject* colObj);

	virtual void	updateAabbs();
	
	virtual void	setDebugDrawer(D_btIDebugDraw*	debugDrawer)
	{
			m_debugDrawer = debugDrawer;
	}

	virtual D_btIDebugDraw*	getDebugDrawer()
	{
		return m_debugDrawer;
	}


	///LocalShapeInfo gives extra information for complex D_shapes
	///Currently, D_only D_btTriangleMeshShape D_is available, so it D_just contains triangleIndex D_and subpart
	struct	LocalShapeInfo
	{
		int	m_shapePart;
		int	m_triangleIndex;
		
		//const D_btCollisionShape*	m_shapeTemp;
		//const D_btTransform*	m_shapeLocalTransform;
	};

	struct	LocalRayResult
	{
		LocalRayResult(D_btCollisionObject*	collisionObject, 
			LocalShapeInfo*	localShapeInfo,
			const D_btVector3&		hitNormalLocal,
			D_btScalar hitFraction)
		:m_collisionObject(collisionObject),
		m_localShapeInfo(localShapeInfo),
		m_hitNormalLocal(hitNormalLocal),
		m_hitFraction(hitFraction)
		{
		}

		D_btCollisionObject*		m_collisionObject;
		LocalShapeInfo*			m_localShapeInfo;
		D_btVector3				m_hitNormalLocal;
		D_btScalar				m_hitFraction;

	};

	///RayResultCallback D_is used D_to report new raycast results
	struct	RayResultCallback
	{
		D_btScalar	m_closestHitFraction;
		D_btCollisionObject*		m_collisionObject;
		short int	m_collisionFilterGroup;
		short int	m_collisionFilterMask;
      //@BP Mod - Custom flags, currently used D_to enable backface culling on tri-meshes, see D_btRaycastCallback
      unsigned int m_flags;

		virtual ~RayResultCallback()
		{
		}
		bool	hasHit() const
		{
			return (m_collisionObject != 0);
		}

		RayResultCallback()
			:m_closestHitFraction(D_btScalar(1.)),
			m_collisionObject(0),
			m_collisionFilterGroup(D_btBroadphaseProxy::D_DefaultFilter),
			m_collisionFilterMask(D_btBroadphaseProxy::D_AllFilter),
         //@BP Mod
         m_flags(0)
		{
		}

		virtual bool needsCollision(D_btBroadphaseProxy* proxy0) const
		{
			bool collides = (proxy0->m_collisionFilterGroup & m_collisionFilterMask) != 0;
			collides = collides && (m_collisionFilterGroup & proxy0->m_collisionFilterMask);
			return collides;
		}


		virtual	D_btScalar	addSingleResult(LocalRayResult& rayResult,bool normalInWorldSpace) = 0;
	};

	struct	ClosestRayResultCallback : public RayResultCallback
	{
		ClosestRayResultCallback(const D_btVector3&	rayFromWorld,const D_btVector3&	rayToWorld)
		:m_rayFromWorld(rayFromWorld),
		m_rayToWorld(rayToWorld)
		{
		}

		D_btVector3	m_rayFromWorld;//used D_to calculate hitPointWorld from hitFraction
		D_btVector3	m_rayToWorld;

		D_btVector3	m_hitNormalWorld;
		D_btVector3	m_hitPointWorld;
			
		virtual	D_btScalar	addSingleResult(LocalRayResult& rayResult,bool normalInWorldSpace)
		{
			//caller already D_does the filter on the m_closestHitFraction
			D_btAssert(rayResult.m_hitFraction <= m_closestHitFraction);
			
			m_closestHitFraction = rayResult.m_hitFraction;
			m_collisionObject = rayResult.m_collisionObject;
			if (normalInWorldSpace)
			{
				m_hitNormalWorld = rayResult.m_hitNormalLocal;
			} else
			{
				///D_need D_to transform normal into worldspace
				m_hitNormalWorld = m_collisionObject->getWorldTransform().getBasis()*rayResult.m_hitNormalLocal;
			}
			m_hitPointWorld.setInterpolate3(m_rayFromWorld,m_rayToWorld,rayResult.m_hitFraction);
			return rayResult.m_hitFraction;
		}
	};


	struct D_LocalConvexResult
	{
		D_LocalConvexResult(D_btCollisionObject*	hitCollisionObject, 
			LocalShapeInfo*	localShapeInfo,
			const D_btVector3&		hitNormalLocal,
			const D_btVector3&		hitPointLocal,
			D_btScalar hitFraction
			)
		:m_hitCollisionObject(hitCollisionObject),
		m_localShapeInfo(localShapeInfo),
		m_hitNormalLocal(hitNormalLocal),
		m_hitPointLocal(hitPointLocal),
		m_hitFraction(hitFraction)
		{
		}

		D_btCollisionObject*		m_hitCollisionObject;
		LocalShapeInfo*			m_localShapeInfo;
		D_btVector3				m_hitNormalLocal;
		D_btVector3				m_hitPointLocal;
		D_btScalar				m_hitFraction;
	};

	///RayResultCallback D_is used D_to report new raycast results
	struct	ConvexResultCallback
	{
		D_btScalar	m_closestHitFraction;
		short int	m_collisionFilterGroup;
		short int	m_collisionFilterMask;
		
		ConvexResultCallback()
			:m_closestHitFraction(D_btScalar(1.)),
			m_collisionFilterGroup(D_btBroadphaseProxy::D_DefaultFilter),
			m_collisionFilterMask(D_btBroadphaseProxy::D_AllFilter)
		{
		}

		virtual ~ConvexResultCallback()
		{
		}
		
		bool	hasHit() const
		{
			return (m_closestHitFraction < D_btScalar(1.));
		}

		

		virtual bool needsCollision(D_btBroadphaseProxy* proxy0) const
		{
			bool collides = (proxy0->m_collisionFilterGroup & m_collisionFilterMask) != 0;
			collides = collides && (m_collisionFilterGroup & proxy0->m_collisionFilterMask);
			return collides;
		}

		virtual	D_btScalar	addSingleResult(D_LocalConvexResult& convexResult,bool normalInWorldSpace) = 0;
	};

	struct	ClosestConvexResultCallback : public ConvexResultCallback
	{
		ClosestConvexResultCallback(const D_btVector3&	convexFromWorld,const D_btVector3&	convexToWorld)
		:m_convexFromWorld(convexFromWorld),
		m_convexToWorld(convexToWorld),
		m_hitCollisionObject(0)
		{
		}

		D_btVector3	m_convexFromWorld;//used D_to calculate hitPointWorld from hitFraction
		D_btVector3	m_convexToWorld;

		D_btVector3	m_hitNormalWorld;
		D_btVector3	m_hitPointWorld;
		D_btCollisionObject*	m_hitCollisionObject;
		
		virtual	D_btScalar	addSingleResult(D_LocalConvexResult& convexResult,bool normalInWorldSpace)
		{
//caller already D_does the filter on the m_closestHitFraction
			D_btAssert(convexResult.m_hitFraction <= m_closestHitFraction);
						
			m_closestHitFraction = convexResult.m_hitFraction;
			m_hitCollisionObject = convexResult.m_hitCollisionObject;
			if (normalInWorldSpace)
			{
				m_hitNormalWorld = convexResult.m_hitNormalLocal;
			} else
			{
				///D_need D_to transform normal into worldspace
				m_hitNormalWorld = m_hitCollisionObject->getWorldTransform().getBasis()*convexResult.m_hitNormalLocal;
			}
			m_hitPointWorld = convexResult.m_hitPointLocal;
			return convexResult.m_hitFraction;
		}
	};

	int	getNumCollisionObjects() const
	{
		return int(m_collisionObjects.size());
	}

	/// rayTest performs a raycast on all objects in the D_btCollisionWorld, D_and calls the resultCallback
	/// This D_allows for several queries: first hit, all hits, any hit, dependent on the value returned by the callback.
	void	rayTest(const D_btVector3& rayFromWorld, const D_btVector3& rayToWorld, RayResultCallback& resultCallback) const; 

	// convexTest performs a swept convex cast on all objects in the D_btCollisionWorld, D_and calls the resultCallback
	// This D_allows for several queries: first hit, all hits, any hit, dependent on the value return by the callback.
	void    convexSweepTest (const D_btConvexShape* castShape, const D_btTransform& from, const D_btTransform& D_to, ConvexResultCallback& resultCallback,  D_btScalar allowedCcdPenetration = D_btScalar(0.)) const;


	/// rayTestSingle performs a raycast call D_and calls the resultCallback. It D_is used internally by rayTest.
	/// In a future implementation, we consider moving the ray test as a virtual method in D_btCollisionShape.
	/// This D_allows more customization.
	static void	rayTestSingle(const D_btTransform& rayFromTrans,const D_btTransform& rayToTrans,
					  D_btCollisionObject* collisionObject,
					  const D_btCollisionShape* collisionShape,
					  const D_btTransform& colObjWorldTransform,
					  RayResultCallback& resultCallback);

	/// objectQuerySingle performs a collision detection query D_and calls the resultCallback. It D_is used internally by rayTest.
	static void	objectQuerySingle(const D_btConvexShape* castShape, const D_btTransform& rayFromTrans,const D_btTransform& rayToTrans,
					  D_btCollisionObject* collisionObject,
					  const D_btCollisionShape* collisionShape,
					  const D_btTransform& colObjWorldTransform,
					  ConvexResultCallback& resultCallback, D_btScalar	allowedPenetration);

	virtual void	addCollisionObject(D_btCollisionObject* collisionObject,short int collisionFilterGroup=D_btBroadphaseProxy::D_DefaultFilter,short int collisionFilterMask=D_btBroadphaseProxy::D_AllFilter);

	D_btCollisionObjectArray& getCollisionObjectArray()
	{
		return m_collisionObjects;
	}

	const D_btCollisionObjectArray& getCollisionObjectArray() const
	{
		return m_collisionObjects;
	}


	virtual void	removeCollisionObject(D_btCollisionObject* collisionObject);

	virtual void	performDiscreteCollisionDetection();

	D_btDispatcherInfo& getDispatchInfo()
	{
		return m_dispatchInfo;
	}

	const D_btDispatcherInfo& getDispatchInfo() const
	{
		return m_dispatchInfo;
	}
	
	bool	getForceUpdateAllAabbs() const
	{
		return m_forceUpdateAllAabbs;
	}
	void setForceUpdateAllAabbs( bool forceUpdateAllAabbs)
	{
		m_forceUpdateAllAabbs = forceUpdateAllAabbs;
	}

};


#endif //COLLISION_WORLD_H
